<strong>TaskApp Auth: Verify Token</strong><br>Write the async auth middleware that reads a Bearer token from Authorization, verifies it, finds the user by decoded id and token, sets req.token and req.user, and sends 401 on error. Assume jwt and User are imported.	<pre style='text-align:left; font-family:monospace;'><code>const auth = async (req, res, next) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const token = req.header('Authorization').replace('Bearer ', '');<br>&nbsp;&nbsp;&nbsp;&nbsp;const decoded = jwt.verify(token, 'sample password');<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = await User.findOne({ _id: decoded.id, 'tokens.token': token });<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!user) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Authentication failed');<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;req.token = token;<br>&nbsp;&nbsp;&nbsp;&nbsp;req.user = user;<br>&nbsp;&nbsp;&nbsp;&nbsp;next();<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(401).send({ error: error.message });<br>&nbsp;&nbsp;}<br>};</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Protected Route</strong><br>Write the GET /me route that uses auth middleware and returns the user or 404, with 500 on errors. Assume router, auth, and User exist.	<pre style='text-align:left; font-family:monospace;'><code>router.get('/me', auth, async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = await User.findById(req.user.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!user) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User not found'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: user<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Failed to fetch users',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Attach Context</strong><br>After verifying the token, what lines attach the token and user to the request object?	<pre style='text-align:left; font-family:monospace;'><code>req.token = token;<br>req.user = user;</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Middleware Goal</strong><br>Why does the auth middleware set req.user and req.token?	So later handlers can reuse the authenticated user and token without re-querying the database.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Invalid Token</strong><br>What status code should the middleware send if token verification fails or the user is not found?	401 Unauthorized with an error message.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Boundary</strong><br>In a route that does NOT use the auth middleware, what is NOT guaranteed about req.user?	It is not set (undefined), so you cannot assume an authenticated user is attached.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fverify%20an%20auth%20token
<strong>TaskApp Auth: Logout</strong><br>Write the /logout route that removes the current token from req.user.tokens and saves the user. Assume auth middleware is used.	<pre style='text-align:left; font-family:monospace;'><code>router.post('/logout', auth, async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;req.user.tokens = req.user.tokens.filter((token) =&gt; token.token !== req.token);<br>&nbsp;&nbsp;&nbsp;&nbsp;await req.user.save();<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logged out successfully'<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logout failed',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogout%20route
<strong>TaskApp Auth: Logout All</strong><br>Write the /logoutAll route that clears all tokens for the authenticated user.	<pre style='text-align:left; font-family:monospace;'><code>router.post('/logoutAll', auth, async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;req.user.tokens = [];<br>&nbsp;&nbsp;&nbsp;&nbsp;await req.user.save();<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logged out from all devices successfully'<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logoutAll failed',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogout%20route
<strong>TaskApp Auth: Logout vs LogoutAll</strong><br>What is the difference between /logout and /logoutAll?	/logout removes only the current token; /logoutAll clears all tokens for the user.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogout%20route
<strong>TaskApp Auth: Logout Persistence</strong><br>What happens if you forget to save the user after filtering tokens?	The token removal is not persisted, so the user stays logged in.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogout%20route
<strong>TaskApp Auth: Logout Effect</strong><br>After a successful /logout, which tokens remain in req.user.tokens?	All tokens except the current one used in req.token.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogout%20route
<strong>TaskApp Env: .env File</strong><br>Write a sample .env file with PORT, DB_HOST, DB_USER, and DB_PASS.	<pre style='text-align:left; font-family:monospace;'><code>PORT=3000<br>DB_HOST=localhost<br>DB_USER=root<br>DB_PASS=password</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fenvironment%20variable
<strong>TaskApp Env: Run Command</strong><br>Write the env-cmd command that loads ./env/.env and runs node your-app.js.	<pre style='text-align:left; font-family:monospace;'><code>npm env-cmd -f ./env/.env node your-app.js</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fenvironment%20variable
<strong>TaskApp Env: Setup</strong><br>How do you set up env-cmd with a local .env file?	Create an env/ directory, put a .env file inside it, and store your variables there.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fenvironment%20variable
<strong>TaskApp Env: Purpose</strong><br>Why use env-cmd for a Node app?	It loads environment variables from a file so the app can read them at runtime.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fenvironment%20variable
<strong>TaskApp Env: Best Practice</strong><br>What is the recommended way to run the env-cmd command repeatedly?	Add it to package.json scripts and run it via npm run start.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fenvironment%20variable
<strong>TaskApp Uploads: Multer Setup</strong><br>Write a basic multer setup that saves images to an avatar folder with a 1MB limit and a fileFilter, then uses upload.single('avatar') in a route.	<pre style='text-align:left; font-family:monospace;'><code>import multer from 'multer';<br><br>const upload = multer({<br>&nbsp;&nbsp;dest: 'avatar',<br>&nbsp;&nbsp;limits: { fileSize: 1000000 },<br>&nbsp;&nbsp;fileFilter: (req, file, cb) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!file.mimetype.startsWith('image/')) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cb(new Error('Only image files are allowed!'), false);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;cb(null, true);<br>&nbsp;&nbsp;}<br>});<br><br>router.post('/me/avatar', upload.single('avatar'), async (req, res) =&gt; {<br>&nbsp;&nbsp;console.log(req.file);<br>&nbsp;&nbsp;res.status(200).send();<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Uploads: Field Name</strong><br>Why is upload.single called with 'avatar'?	Because the form field name is expected to be avatar.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Uploads: Store in DB</strong><br>Write the route that stores the uploaded avatar in the database as a Buffer. Assume auth middleware and multer without dest.	<pre style='text-align:left; font-family:monospace;'><code>const upload = multer({});<br><br>router.post('/me/avatar', auth, upload.single('avatar'), async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const buffer = req.file.buffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;req.user.avatar = buffer;<br>&nbsp;&nbsp;&nbsp;&nbsp;await req.user.save();<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Avatar uploaded successfully'<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Avatar upload failed',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Uploads: Model Field</strong><br>Write the Mongoose field definition for storing a user avatar as a Buffer.	<pre style='text-align:left; font-family:monospace;'><code>avatar: {<br>&nbsp;&nbsp;type: Buffer<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Uploads: Send Image</strong><br>What code sets the response Content-Type and sends the avatar buffer?	<pre style='text-align:left; font-family:monospace;'><code>res.set('Content-Type', 'image/png');<br>res.send(user.avatar);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Uploads: Get Avatar Route</strong><br>Write the route that retrieves a user's avatar by id and returns 404 if missing.	<pre style='text-align:left; font-family:monospace;'><code>router.get('/:id/avatar', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = await User.findById(req.params.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!user || !user.avatar) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Avatar not found'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;res.set('Content-Type', 'image/png');<br>&nbsp;&nbsp;&nbsp;&nbsp;res.send(user.avatar);<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Failed to fetch avatar',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffile%20uploads%2Ffile%20uploads
<strong>TaskApp Filtering: GET /tasks</strong><br>Write the route that optionally filters tasks by completed using req.query.completed.	<pre style='text-align:left; font-family:monospace;'><code>router.get('/', auth, async (req, res) =&gt; {<br>&nbsp;&nbsp;let match = {};<br>&nbsp;&nbsp;if (req.query.completed) {<br>&nbsp;&nbsp;&nbsp;&nbsp;match.completed = req.query.completed === 'true';<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const tasks = await Task.find({ owner: req.user.id, ...match })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.populate('owner', 'name email');<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: tasks.length,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tasks: tasks<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'Failed to fetch tasks',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffiltering%2Ffiltering%20timeline
<strong>TaskApp Filtering: Match Object</strong><br>Why use a match object when building the Task.find filter?	It lets you conditionally add filters only when the query param exists.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffiltering%2Ffiltering%20timeline
<strong>TaskApp Filtering: Missing Query</strong><br>If req.query.completed is missing, what does match look like and what tasks are returned?	match stays empty and all tasks for the user are returned.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffiltering%2Ffiltering%20timeline
<strong>TaskApp Filtering: Boolean Coercion</strong><br>How is req.query.completed converted to a boolean?	By checking if req.query.completed === 'true'.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffiltering%2Ffiltering%20timeline
<strong>TaskApp Filtering: Comparison</strong><br>What is the difference between optional query filtering and a hardcoded filter?	Query filtering allows per-request criteria; hardcoded filters are always applied.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Ffiltering%2Ffiltering%20timeline
<strong>TaskApp Models: Task Owner Ref</strong><br>Write the Task schema field that references the User model as owner.	<pre style='text-align:left; font-family:monospace;'><code>owner: {<br>&nbsp;&nbsp;type: mongoose.Schema.Types.ObjectId,<br>&nbsp;&nbsp;required: true,<br>&nbsp;&nbsp;ref: 'User'<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Models: Normalization</strong><br>Why add a ref to the User model instead of embedding the user data?	It normalizes the data so the task stores a reference and stays consistent.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Models: Populate Ref</strong><br>Write a simple Mongoose populate example that loads the author field.	<pre style='text-align:left; font-family:monospace;'><code>const courses = await Course<br>&nbsp;&nbsp;.find()<br>&nbsp;&nbsp;.populate('author');</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Models: Virtual Relationship</strong><br>Write the userSchema.virtual configuration that links a user to tasks.	<pre style='text-align:left; font-family:monospace;'><code>userSchema.virtual('tasks', {<br>&nbsp;&nbsp;ref: 'Task',<br>&nbsp;&nbsp;localField: '_id',<br>&nbsp;&nbsp;foreignField: 'owner'<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Models: Populate Tasks</strong><br>Write the query that finds a user and populates tasks.	<pre style='text-align:left; font-family:monospace;'><code>const user = await User.findById('6882a097addee5f2896dd669')<br>&nbsp;&nbsp;.populate('tasks');</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Models: Normalize vs Denormalize</strong><br>How is normalization different from denormalization in MongoDB models?	Normalization stores references (ObjectId) and uses populate; denormalization embeds data directly.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2F2%20models%20relationship
<strong>TaskApp Auth: Hide Private Fields</strong><br>Write the userSchema.toJSON method that removes password and tokens from the response.	<pre style='text-align:left; font-family:monospace;'><code>userSchema.methods.toJSON = function () {<br>&nbsp;&nbsp;const user = this;<br>&nbsp;&nbsp;const userObject = user.toObject();<br>&nbsp;&nbsp;delete userObject.password;<br>&nbsp;&nbsp;delete userObject.tokens;<br>&nbsp;&nbsp;return userObject;<br>};</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fhide%20private%20data%20for%20the%20user%20endpoint
<strong>TaskApp Auth: toJSON Purpose</strong><br>Why override toJSON in the User model?	To hide sensitive fields like password and tokens from API responses.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fhide%20private%20data%20for%20the%20user%20endpoint
<strong>TaskApp Auth: toObject vs toJSON</strong><br>What is the difference between toObject and toJSON in this context?	toObject converts a Mongoose document to a plain object; toJSON lets you customize what gets serialized.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fhide%20private%20data%20for%20the%20user%20endpoint
<strong>TaskApp Auth: Sensitive Fields</strong><br>Which fields should NOT be returned to clients in the user response?	password and tokens.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fhide%20private%20data%20for%20the%20user%20endpoint
<strong>TaskApp Auth: Serialization Effect</strong><br>After overriding toJSON, what happens when res.json(user) is called?	The response omits password and tokens.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fhide%20private%20data%20for%20the%20user%20endpoint
<strong>TaskApp Auth: Tokens Field</strong><br>Write the user schema snippet that stores auth tokens as an array.	<pre style='text-align:left; font-family:monospace;'><code>const userSchema = new mongoose.Schema({<br>&nbsp;&nbsp;name: { type: String, required: true, trim: true },<br>&nbsp;&nbsp;email: { type: String, required: true, unique: true, trim: true, lowercase: true },<br>&nbsp;&nbsp;password: { type: String, required: true, minlength: 6 },<br>&nbsp;&nbsp;tokens: [{<br>&nbsp;&nbsp;&nbsp;&nbsp;token: { type: String, required: true }<br>&nbsp;&nbsp;}]<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Generate Token</strong><br>Write the generateAuthTokens instance method for the User model.	<pre style='text-align:left; font-family:monospace;'><code>userSchema.methods.generateAuthTokens = async function () {<br>&nbsp;&nbsp;const user = this;<br>&nbsp;&nbsp;const token = jwt.sign({ id: user._id }, 'sample password', { expiresIn: '2 days' });<br>&nbsp;&nbsp;user.tokens = user.tokens.concat({ token });<br>&nbsp;&nbsp;await user.save();<br>&nbsp;&nbsp;return token;<br>};</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Use Token Method</strong><br>In a route, what line generates a token after finding a user?	<pre style='text-align:left; font-family:monospace;'><code>const token = await user.generateAuthTokens();</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Login With Token</strong><br>Write the login route snippet that uses findByCredentials and returns a token.	<pre style='text-align:left; font-family:monospace;'><code>router.post('/login', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = await User.findByCredentials(req.body.email, req.body.password);<br>&nbsp;&nbsp;&nbsp;&nbsp;const token = await user.generateAuthTokens();<br>&nbsp;&nbsp;&nbsp;&nbsp;return res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logged in successfully',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: { id: user._id, name: user.name, email: user.email, tokens: user.tokens }<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User login failed',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error: error.message<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Tokens Array</strong><br>Why store tokens in an array on the user document?	To support multiple active sessions or devices per user.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Token Persistence</strong><br>After generateAuthTokens runs, where is the token stored?	It is appended to user.tokens and saved on the user document.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fgenerate%20an%20auth%20token
<strong>TaskApp Auth: Login Route</strong><br>Write the login route that checks email/password with bcrypt and returns user info.	<pre style='text-align:left; font-family:monospace;'><code>router.post('/login', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const { email, password } = req.body;<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = await User.findOne({ email: email });<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!user) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({ success: false, message: 'User not found' });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;const isMatch = await bcrypt.compare(password, user.password);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!isMatch) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(400).json({ success: false, message: 'Invalid credentials' });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return res.status(200).json({<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message: 'User logged in successfully',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: { id: user._id, name: user.name, email: user.email }<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({ success: false, message: 'User login failed', error: error.message });<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogin%20route
<strong>TaskApp Auth: findByCredentials</strong><br>Write the User model static method that validates credentials.	<pre style='text-align:left; font-family:monospace;'><code>userSchema.statics.findByCredentials = async function (email, password) {<br>&nbsp;&nbsp;const user = await this.findOne({ email });<br>&nbsp;&nbsp;if (!user) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('User not found');<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;const isMatch = await bcrypt.compare(password, user.password);<br>&nbsp;&nbsp;if (!isMatch) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Invalid credentials');<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return user;<br>};</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogin%20route
<strong>TaskApp Auth: Encapsulation</strong><br>Why move login logic into findByCredentials on the schema?	It centralizes credential checks and keeps route handlers thin and reusable.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogin%20route
<strong>TaskApp Auth: Missing User</strong><br>In the login route, what response is returned if the user is not found?	404 with a JSON message "User not found".	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogin%20route
<strong>TaskApp Auth: Comparison</strong><br>How is the schema method approach different from checking credentials directly in the route?	The schema method encapsulates the logic so routes can reuse it and remain simpler.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Flogin%20route
<strong>JWT Basics: Sign</strong><br>Write the code that signs a JWT for a user id using jwtPrivateKey.	<pre style='text-align:left; font-family:monospace;'><code>const token = jwt.sign({ _id: user._id }, config.get('jwtPrivateKey'));</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fbasics%20of%20JWT
<strong>JWT Basics: Verify</strong><br>Write the code that verifies a JWT using jwtPrivateKey.	<pre style='text-align:left; font-family:monospace;'><code>const decoded = jwt.verify(token, config.get('jwtPrivateKey'));</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fbasics%20of%20JWT
<strong>JWT Basics: Purpose of Sign</strong><br>What does jwt.sign do in authentication?	It creates a token after successful login or registration.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fbasics%20of%20JWT
<strong>JWT Basics: Purpose of Verify</strong><br>What does jwt.verify do in authorization?	It validates the token so a user can access protected resources.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fbasics%20of%20JWT
<strong>JWT Basics: Sign vs Verify</strong><br>What is the difference between jwt.sign and jwt.verify?	Sign creates a token; verify validates an existing token.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fbasics%20of%20JWT
<strong>TaskApp Auth: Hash on Save</strong><br>Write the pre-save middleware that hashes the password if it was modified.	<pre style='text-align:left; font-family:monospace;'><code>userSchema.pre('save', function (next) {<br>&nbsp;&nbsp;if (this.isModified('password')) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.password = bcrypt.hashSync(this.password, 8);<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;next();<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fdecrypting%20passwords%20in%20a%20middleware
<strong>TaskApp Auth: isModified Check</strong><br>Why check this.isModified('password') before hashing?	To avoid re-hashing an unchanged password.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fdecrypting%20passwords%20in%20a%20middleware
<strong>TaskApp Auth: Predictive</strong><br>What happens in this middleware when a user saves without changing the password?	No hashing occurs and the password stays the same.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fdecrypting%20passwords%20in%20a%20middleware
<strong>TaskApp Auth: Failure Mode</strong><br>What goes wrong if you hash the password on every save without checking isModified?	You double-hash the password and break future logins.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fdecrypting%20passwords%20in%20a%20middleware
<strong>TaskApp Auth: Hashing Location</strong><br>Where is password hashing implemented in this approach?	In the User model as a pre('save') middleware.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fdecrypting%20passwords%20in%20a%20middleware
<strong>TaskApp Tasks: Patch via findByIdAndUpdate</strong><br>Write the basic patch route using findByIdAndUpdate.	<pre style='text-align:left; font-family:monospace;'><code>app.patch('/tasks/:id', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const task = await Task.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!task) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({ success: false, message: 'Task not found' });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({ success: true, message: 'Task updated successfully', task: task });<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({ success: false, message: 'Task update failed', error: error.message });<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fupdate%20resources
<strong>TaskApp Tasks: Patch with Middleware</strong><br>Write the patch route that validates allowed updates and uses task.save().	<pre style='text-align:left; font-family:monospace;'><code>router.patch('/:id', async (req, res) =&gt; {<br>&nbsp;&nbsp;const updates = Object.keys(req.body);<br>&nbsp;&nbsp;const allowedUpdates = ['description', 'completed', 'title'];<br>&nbsp;&nbsp;const isValidOperation = updates.every((update) =&gt; allowedUpdates.includes(update));<br>&nbsp;&nbsp;if (!isValidOperation) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return res.status(400).json({ error: 'Invalid updates!' });<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const task = await Task.findById(req.params.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!task) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({ success: false, message: 'Task not found' });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;updates.forEach((update) =&gt; task[update] = req.body[update]);<br>&nbsp;&nbsp;&nbsp;&nbsp;await task.save();<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({ success: true, message: 'Task updated successfully', task: task });<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({ success: false, message: 'Task update failed', error: error.message });<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fupdate%20resources
<strong>TaskApp Tasks: Middleware Reason</strong><br>Why avoid findByIdAndUpdate when you need middleware to run?	findByIdAndUpdate bypasses document middleware, while findById + save triggers it.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fupdate%20resources
<strong>TaskApp Tasks: Invalid Updates</strong><br>What response is returned when an update includes a field not in allowedUpdates?	400 with an "Invalid updates!" error.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fupdate%20resources
<strong>TaskApp Tasks: Comparison</strong><br>How does manual update + save differ from findByIdAndUpdate?	Manual update runs validation and middleware on save; findByIdAndUpdate does not.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fupdate%20resources
<strong>TaskApp Routers: Setup</strong><br>Write the router setup that mounts user and task routers.	<pre style='text-align:left; font-family:monospace;'><code>import userRouter from './users.js';<br>import taskRouter from './tasks.js';<br><br>const router = express.Router();<br><br>app.use('/users', userRouter);<br>app.use('/tasks', taskRouter);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Frouters
<strong>TaskApp Routers: Example Router</strong><br>Write a basic router that creates a user with POST /.	<pre style='text-align:left; font-family:monospace;'><code>import express from 'express';<br>import { User } from '../models/user.js';<br><br>const router = express.Router();<br><br>router.post('/', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const user = new User(req.body);<br>&nbsp;&nbsp;&nbsp;&nbsp;await user.save();<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(201).json({ success: true, message: 'User created successfully', user: user });<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(400).json({ success: false, message: 'User creation failed', error: error.message });<br>&nbsp;&nbsp;}<br>});<br><br>export default router;</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Frouters
<strong>TaskApp Routers: Purpose</strong><br>Why use express.Router in a Node app?	To group related routes and mount them under a base path.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Frouters
<strong>TaskApp Routers: Boundary</strong><br>Where should the database connection NOT be created?	Not inside each router; connect once in the main file and use models elsewhere.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Frouters
<strong>TaskApp Routers: Mount Effect</strong><br>If you mount app.use('/users', userRouter), what is the full path for router.post('/')?	/users	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Frouters
<strong>TaskApp Tasks: Delete Route</strong><br>Write the delete route that removes a task by id and returns 404 if missing.	<pre style='text-align:left; font-family:monospace;'><code>app.delete('/tasks/:id', async (req, res) =&gt; {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const task = await Task.findByIdAndDelete(req.params.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!task) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return res.status(404).json({ success: false, message: 'Task not found' });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(200).json({ success: true, message: 'Task deleted successfully', task: task });<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;res.status(500).json({ success: false, message: 'Task deletion failed', error: error.message });<br>&nbsp;&nbsp;}<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fdelete%20resources
<strong>TaskApp Tasks: Delete Missing</strong><br>What response should be returned when a task is not found during delete?	404 with a "Task not found" message.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fdelete%20resources
<strong>TaskApp Tasks: Delete Response</strong><br>Why return the deleted task in the response?	It confirms which document was removed and provides feedback to the client.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fdelete%20resources
<strong>TaskApp Tasks: Delete vs Patch</strong><br>How does delete differ from patch in REST?	Delete removes a document; patch updates selected fields.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fdelete%20resources
<strong>TaskApp Tasks: Delete Error</strong><br>What status code is used for errors during deletion?	500 with an error message.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Frouters%2Fdelete%20resources
<strong>MongoDB: Connect Function</strong><br>Write the async function that connects to MongoDB and returns { client, db }.	<pre style='text-align:left; font-family:monospace;'><code>const mongodb = require('mongodb');<br>const MongoClient = mongodb.MongoClient;<br>const url = 'mongodb://localhost:27017';<br>const dbName = 'taskmanager';<br><br>async function connectToDatabase() {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const client = await MongoClient.connect(url);<br>&nbsp;&nbsp;&nbsp;&nbsp;const db = client.db(dbName);<br>&nbsp;&nbsp;&nbsp;&nbsp;return { client, db };<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw error;<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>MongoDB: Insert</strong><br>Write an example that inserts one document and many documents.	<pre style='text-align:left; font-family:monospace;'><code>const res = await db.collection('users').insertOne({ name: 'mohamed', age: 20 });<br><br>const results = await db.collection('meta').insertMany([<br>&nbsp;&nbsp;{ description: 'what is the task about ', completed: true },<br>&nbsp;&nbsp;{ description: 'what is the task about 2', completed: false },<br>&nbsp;&nbsp;{ description: 'what is the task about 3', completed: true }<br>]);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>MongoDB: InsertOne vs InsertMany</strong><br>What is the difference between insertOne and insertMany?	insertOne inserts a single document; insertMany inserts multiple documents.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>MongoDB: ObjectId Demo</strong><br>Write a snippet that creates an ObjectId and logs its hex string length.	<pre style='text-align:left; font-family:monospace;'><code>const { MongoClient, ObjectId } = require('mongodb');<br>let id = new ObjectId();<br>console.log(id.toHexString().length);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>MongoDB: Read</strong><br>Write examples of findOne and find().toArray().	<pre style='text-align:left; font-family:monospace;'><code>db.collection('users').findOne({ name: 'mohamed' })<br>&nbsp;&nbsp;.then(user =&gt; { console.log('User found:', user); });<br><br>db.collection('meta').find({ completed: true }).toArray()<br>&nbsp;&nbsp;.then(docs =&gt; { console.log('Metas found:', docs); });</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>MongoDB: findOne vs find</strong><br>How does findOne differ from find?	findOne returns a single document; find returns a cursor for multiple documents.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fmongodb
<strong>Dynamic Views: Install hbs</strong><br>Write the npm command to install hbs.	<pre style='text-align:left; font-family:monospace;'><code>npm install hbs</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: View Engine</strong><br>Write the app.js lines to set hbs as the view engine.	<pre style='text-align:left; font-family:monospace;'><code>const hbs = require('hbs');<br>app.set('view engine', 'hbs');</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Custom Views Path</strong><br>Write the line that sets the views directory to ../templates.	<pre style='text-align:left; font-family:monospace;'><code>app.set('views', path.join(__dirname, '../templates'));</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Render Route</strong><br>Write a route that renders index with title and message.	<pre style='text-align:left; font-family:monospace;'><code>app.get('/', (req, res) =&gt; {<br>&nbsp;&nbsp;res.render('index', {<br>&nbsp;&nbsp;&nbsp;&nbsp;title: 'Home Page',<br>&nbsp;&nbsp;&nbsp;&nbsp;message: 'Welcome to the Home Page!'<br>&nbsp;&nbsp;});<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Template Usage</strong><br>Write a minimal index.hbs template that renders title and message.	<pre style='text-align:left; font-family:monospace;'><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang="en"&gt;<br>&lt;head&gt;<br>&nbsp;&nbsp;&lt;meta charset="UTF-8"&gt;<br>&nbsp;&nbsp;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br>&nbsp;&nbsp;&lt;title&gt;{{title}}&lt;/title&gt;<br>&nbsp;&nbsp;&lt;link rel="stylesheet" href="/css/styles.css"&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&nbsp;&nbsp;&lt;h1&gt;{{message}}&lt;/h1&gt;<br>&nbsp;&nbsp;&lt;p&gt;This is the home page.&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Register Partials</strong><br>Write the configuration to register hbs partials and custom views path.	<pre style='text-align:left; font-family:monospace;'><code>const hbs = require('hbs');<br><br>const viewsPath = path.join(__dirname, '../views/views/');<br>const partialsPath = path.join(__dirname, '../views/partials/');<br><br>hbs.registerPartials(partialsPath);<br>app.set('views', viewsPath);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Nodemon Watch</strong><br>Write the nodemon command that watches js and hbs files.	<pre style='text-align:left; font-family:monospace;'><code>nodemon src/app.js -e js,hbs</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Header Partial</strong><br>Write a header.hbs partial with a title and nav links.	<pre style='text-align:left; font-family:monospace;'><code>&lt;h1&gt;{{title}}&lt;/h1&gt;<br>&lt;nav&gt;<br>&nbsp;&nbsp;&lt;ul&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;a href="/about"&gt;About&lt;/a&gt;&lt;/li&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;a href="/help"&gt;Help&lt;/a&gt;&lt;/li&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;&lt;a href="/weather"&gt;Weather&lt;/a&gt;&lt;/li&gt;<br>&nbsp;&nbsp;&lt;/ul&gt;<br>&lt;/nav&gt;<br>&lt;p&gt; this site is made by {{name}}&lt;/p&gt;</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Include Partial</strong><br>How do you include the header partial in a view?	<pre style='text-align:left; font-family:monospace;'><code>{{&gt;header}}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Pass Header Data</strong><br>Write the route that renders index and passes title and name for the header.	<pre style='text-align:left; font-family:monospace;'><code>app.get('/', (req, res) =&gt; {<br>&nbsp;&nbsp;res.render('index', {<br>&nbsp;&nbsp;&nbsp;&nbsp;title: 'Home Page',<br>&nbsp;&nbsp;&nbsp;&nbsp;name: 'Your Name'<br>&nbsp;&nbsp;});<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: 404 Route</strong><br>Write the route that renders a 404 view for unknown pages.	<pre style='text-align:left; font-family:monospace;'><code>app.get('/{*any}', (req, res) =&gt; {<br>&nbsp;&nbsp;res.render('404', {<br>&nbsp;&nbsp;&nbsp;&nbsp;title: '404',<br>&nbsp;&nbsp;&nbsp;&nbsp;message: 'Page not found'<br>&nbsp;&nbsp;});<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Dynamic Views: Fetch Weather</strong><br>Write the client-side script that fetches /weather?address=... and updates message elements.	<pre style='text-align:left; font-family:monospace;'><code>const weatherForm = document.querySelector('form');<br>const search = document.querySelector('input');<br>const messageOne = document.querySelector('#message-1');<br>const messageTwo = document.querySelector('#message-2');<br><br>weatherForm.addEventListener('submit', (e) =&gt; {<br>&nbsp;&nbsp;e.preventDefault();<br>&nbsp;&nbsp;const location = search.value;<br>&nbsp;&nbsp;messageOne.textContent = 'Loading...';<br>&nbsp;&nbsp;messageTwo.textContent = '';<br>&nbsp;&nbsp;fetch('/weather?address=' + encodeURIComponent(location)).then((response) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return response.json();<br>&nbsp;&nbsp;}).then((data) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;messageOne.textContent = data.location;<br>&nbsp;&nbsp;&nbsp;&nbsp;messageTwo.textContent = data.weather_descriptions[0] + '. It is currently ' + data.temperature + ' degress out. It feels like ' + data.feelslike + ' degress out.';<br>&nbsp;&nbsp;}).catch((error) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;messageOne.textContent = 'An error occurred: ' + error.message;<br>&nbsp;&nbsp;&nbsp;&nbsp;messageTwo.textContent = '';<br>&nbsp;&nbsp;});<br>});</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fdynamic%20views
<strong>Static Assets: Serve Public</strong><br>Write the Express middleware that serves static assets from the public directory.	<pre style='text-align:left; font-family:monospace;'><code>app.use(express.static(path.join(__dirname, '../public')));</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fstatic%20assets
<strong>Static Assets: Folder Layout</strong><br>Where should static assets live and how should they be organized?	In the public directory, split into subfolders like css, js, images.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fstatic%20assets
<strong>Static Assets: URL Access</strong><br>How do you access static files after using express.static?	Via URLs like /index.html, /about.html, /contact.html that map to public/.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fstatic%20assets
<strong>Static Assets: Boundary</strong><br>What directory is NOT used for static assets in this setup?	Not the src directory; static files belong in public.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fstatic%20assets
<strong>Static Assets: Setup Steps</strong><br>What two steps are required to serve static assets?	Create the public directory and register express.static in app.js.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2Fstatic%20assets
<strong>HTTP Basics: TCP</strong><br>What is TCP in web communication?	A protocol that establishes connections and splits data into packets.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Port</strong><br>What is a port?	A number that lets a computer route incoming packets to the correct program.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: HTTP</strong><br>What is HTTP?	A set of rules for structuring data transferred over the web.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: MIME Type</strong><br>What is a MIME type?	A standard that specifies the type of data being sent over the web.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: API</strong><br>What is an API?	A set of rules for how software components interact.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Endpoint</strong><br>What is an endpoint?	A specific URL exposed by an API for client interaction.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Serialize</strong><br>What does it mean to serialize an object?	Translate it into a transferable format like JSON or XML.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Deserialize</strong><br>What does it mean to deserialize?	Convert serialized data back into its original object form.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Routing</strong><br>What is routing in a server?	Mapping HTTP requests to content or handlers.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>HTTP Basics: Environment Variable</strong><br>What is an environment variable on a server?	A global variable specific to the server environment.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2FHTTP%20and%20being%20a%20web%20server
<strong>Node Events: Emitter Core</strong><br>Write the simplified EventEmitter implementation with on and emit.	<pre style='text-align:left; font-family:monospace;'><code>function Emitter() {<br>&nbsp;&nbsp;this.events = {};<br>}<br><br>Emitter.prototype.on = function (event, listener) {<br>&nbsp;&nbsp;if (!this.events[event]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.events[event] = [];<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;this.events[event].push(listener);<br};<br><br>Emitter.prototype.emit = function (event, ...args) {<br>&nbsp;&nbsp;if (this.events[event]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.events[event].forEach((listener) =&gt; listener(...args));<br>&nbsp;&nbsp;}<br};</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Events: Greetr Example</strong><br>Write the EventEmitter inheritance example that emits a greet event.	<pre style='text-align:left; font-family:monospace;'><code>let EventEmitter = require('events');<br>let util = require('util');<br><br>function Greetr() {<br>&nbsp;&nbsp;EventEmitter.call(this);<br>&nbsp;&nbsp;this.greeting = 'Hello world!';<br>}<br><br>util.inherits(Greetr, EventEmitter);<br><br>Greetr.prototype.greet = function () {<br>&nbsp;&nbsp;console.log(this.greeting);<br>&nbsp;&nbsp;this.emit('greet');<br};<br><br>let greeter1 = new Greetr();<br>greeter1.on('greet', function () {<br>&nbsp;&nbsp;console.log('Someone greeted!');<br});<br>greeter1.greet();</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Streams: Pipe</strong><br>Write the stream pipe example that copies and gzips a file.	<pre style='text-align:left; font-family:monospace;'><code>let fs = require('fs');<br>let zlib = require('zlib');<br><br>let input = fs.createReadStream('greet.txt');<br>let copy = fs.createWriteStream('copy.txt');<br>let compressed = fs.createWriteStream('greet.txt.gz');<br>let compress = zlib.createGzip();<br><br>input.pipe(copy);<br>input.pipe(compress).pipe(compressed);</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Promises: Read File</strong><br>Write the readFile example using node:fs/promises and __dirname.	<pre style='text-align:left; font-family:monospace;'><code>import { readFile } from 'node:fs/promises';<br>import { fileURLToPath } from 'node:url';<br>import { dirname } from 'node:path';<br><br>const __filename = fileURLToPath(import.meta.url);<br>const __dirname = dirname(__filename);<br>const filePath = `${__dirname}/greet.txt`;<br><br>async function readFileContent() {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const data = await readFile(filePath, 'utf8');<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(data);<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error reading file:', error);<br>&nbsp;&nbsp;}<br>}<br><br>readFileContent();</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Promises: Stream Copy</strong><br>Write the async example that opens file handles and streams data to a copy.	<pre style='text-align:left; font-family:monospace;'><code>import { open } from 'node:fs/promises';<br>import { fileURLToPath } from 'node:url';<br>import { dirname } from 'node:path';<br><br>const __filename = fileURLToPath(import.meta.url);<br>const __dirname = dirname(__filename);<br>const filePath = `${__dirname}/greet.txt`;<br>const copyFilePath = `${__dirname}/copy.txt`;<br><br>async function readFileContent() {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const readHandle = await open(filePath, 'r');<br>&nbsp;&nbsp;&nbsp;&nbsp;const writeHandle = await open(copyFilePath, 'w+');<br>&nbsp;&nbsp;&nbsp;&nbsp;const writable = await writeHandle.createWriteStream();<br>&nbsp;&nbsp;&nbsp;&nbsp;const readable = await readHandle.createReadStream();<br>&nbsp;&nbsp;&nbsp;&nbsp;for await (const chunk of readable) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable.write(chunk);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;writable.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;readHandle.close();<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error reading file:', error);<br>&nbsp;&nbsp;}<br>}<br><br>readFileContent();</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Promises: Pipeline</strong><br>Write the pipeline example that copies and gzips using stream/promises.	<pre style='text-align:left; font-family:monospace;'><code>import { open } from 'node:fs/promises';<br>import { createGzip } from 'node:zlib';<br>import { pipeline } from 'node:stream/promises';<br>import { fileURLToPath } from 'node:url';<br>import { dirname } from 'node:path';<br><br>const __filename = fileURLToPath(import.meta.url);<br>const __dirname = dirname(__filename);<br>const filePath = `${__dirname}/greet.txt`;<br>const copyFilePath = `${__dirname}/copy.txt`;<br><br>async function readFileContent() {<br>&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;const readHandle = await open(filePath, 'r');<br>&nbsp;&nbsp;&nbsp;&nbsp;const writeHandle = await open(copyFilePath, 'w+');<br>&nbsp;&nbsp;&nbsp;&nbsp;const compressed = await open(`${filePath}.gz`, 'w+');<br>&nbsp;&nbsp;&nbsp;&nbsp;const gzip = createGzip();<br>&nbsp;&nbsp;&nbsp;&nbsp;const readable = readHandle.createReadStream();<br>&nbsp;&nbsp;&nbsp;&nbsp;const writable = writeHandle.createWriteStream();<br>&nbsp;&nbsp;&nbsp;&nbsp;const compressedstream = compressed.createWriteStream();<br>&nbsp;&nbsp;&nbsp;&nbsp;await Promise.all([<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pipeline(readable, writable),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pipeline(readable, gzip, compressedstream)<br>&nbsp;&nbsp;&nbsp;&nbsp;]);<br>&nbsp;&nbsp;&nbsp;&nbsp;await Promise.all([readHandle.close(), writeHandle.close(), compressed.close()]);<br>&nbsp;&nbsp;} catch (error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error('Error reading file:', error);<br>&nbsp;&nbsp;}<br>}<br><br>readFileContent();</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Events: Mental Model</strong><br>How is the EventEmitter structured under the hood?	An object where each event name maps to an array of listener functions.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Async: libuv Role</strong><br>What does libuv do for asynchronous I/O in Node?	It asks the OS to perform I/O, queues callbacks, and triggers them when operations complete.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Events: Predictive Output</strong><br>What is printed when greeter1.greet() runs in the Greetr example?	First "Hello world!" then "Someone greeted!".	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>Node Async: Boundary</strong><br>What is NOT true about the JS engine when embedded in Node?	It is not purely synchronous because Node adds async behavior via the event loop and libuv.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Falicea%2Fasynchronous%20code%20and%20streams
<strong>TaskApp Auth: Hash Password</strong><br>Write the register-time hashPassword function using bcrypt.	<pre style='text-align:left; font-family:monospace;'><code>const bcrypt = require('bcrypt');<br><br>async function hashPassword(password) {<br>&nbsp;&nbsp;const salt = await bcrypt.genSalt(10);<br>&nbsp;&nbsp;let hashed = await bcrypt.hash(password, salt);<br>&nbsp;&nbsp;return hashed;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fthe%20idea%20behind%20bcrypt
<strong>TaskApp Auth: Verify Password</strong><br>Write the login-time verifyPassword function using bcrypt.compare.	<pre style='text-align:left; font-family:monospace;'><code>const bcrypt = require('bcrypt');<br>async function verifyPassword(inputPassword, hashedPassword) {<br>&nbsp;&nbsp;const isMatch = await bcrypt.compare(inputPassword, hashedPassword);<br>&nbsp;&nbsp;return isMatch;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fthe%20idea%20behind%20bcrypt
<strong>TaskApp Auth: Why Hash</strong><br>Why hash passwords before storing them in the database?	So if the database is compromised, the original passwords are not exposed.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fthe%20idea%20behind%20bcrypt
<strong>TaskApp Auth: Boundary</strong><br>Why can't you decrypt a bcrypt hash to get the original password?	Hashing is one-way; you can only compare by hashing the input again.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fthe%20idea%20behind%20bcrypt
<strong>TaskApp Auth: Register vs Login</strong><br>How does password handling differ between registration and login?	Registration hashes and stores the password; login hashes the input and compares to the stored hash.	obsidian://open?vault=mohamed&file=programming%2Fnode%2Fandrew%2FtaskApp%2Fauth%2Fthe%20idea%20behind%20bcrypt
