<strong>DSA: Trees vs Arrays</strong><br>What is the fundamental trade-off between Arrays and Linked Lists regarding Search vs Insertion?	<strong>Arrays</strong>: Fast Search O(log n), Slow Insertion.<br><strong>Linked Lists</strong>: Fast Insertion O(1), Slow Search.	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbalanced%20tree
<strong>DSA: AVL Trees</strong><br>What is the "Balance Factor" of a node?	Height(Left Subtree) - Height(Right Subtree).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbalanced%20tree
<strong>DSA: AVL Trees</strong><br>At what Balance Factor threshold does an AVL tree trigger a rotation?	When the factor is <strong>-2</strong> or <strong>2</strong> (Invalid states).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbalanced%20tree
<strong>DSA: B-Trees</strong><br>Why are B-Trees preferred over Binary Trees for databases?	They optimize for <strong>Disk I/O</strong> ("Seek Time"). By having multiple keys per node (wide structure), they minimize the number of expensive disk fetches needed to find data.	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbalanced%20tree
<strong>DSA: Binary Search</strong><br>Write the <strong>Iterative</strong> Binary Search function.<br>Context: `vector<int> &x`, `int number`.	<pre style='text-align:left; font-family:monospace;'><code>int bs_iterative(vector<int> &x, int number) {<br>&nbsp;&nbsp;int low = 0;<br>&nbsp;&nbsp;int high = x.size() - 1;<br>&nbsp;&nbsp;while (low <= high) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int mid = low + (high - low) / 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;int guess = x[mid];<br>&nbsp;&nbsp;&nbsp;&nbsp;if (guess == number) return mid;<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (guess < number) low = mid + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;else high = mid - 1;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return -1;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbinary%20search
<strong>DSA: Binary Search</strong><br>Why do we calculate `mid` as `low + (high - low) / 2` instead of `(low + high) / 2`?	To prevent <strong>Integer Overflow</strong>. If `low` and `high` are large, their sum might exceed `INT_MAX`.	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbinary%20search
<strong>DSA: Binary Search</strong><br>What is the loop condition for a standard binary search?	`while (low <= high)` (Must include equality to check the final element).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fgrokking%20algorithm%2Fbinary%20search
<strong>DSA: Hash Tables</strong><br>Write a `hash` function that converts a string key to an index.<br>Context: `int SIZE`, Prime `23`.	<pre style='text-align:left; font-family:monospace;'><code>int hash(string key) {<br>&nbsp;&nbsp;int hash = 0;<br>&nbsp;&nbsp;for (int i = 0; i < key.length(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int asciiValue = int(key[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;hash = (hash + asciiValue * 23) % SIZE;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return hash;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHASH%20TABLES
<strong>DSA: Hash Tables</strong><br>Write the `set(key, value)` function using Separate Chaining.<br>Context: `Node* dataMap[SIZE]`.	<pre style='text-align:left; font-family:monospace;'><code>void set(string key, int value) {<br>&nbsp;&nbsp;int index = hash(key);<br>&nbsp;&nbsp;Node* newNode = new Node(key, value);<br>&nbsp;&nbsp;if (dataMap[index] == nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;dataMap[index] = newNode;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;Node* temp = dataMap[index];<br>&nbsp;&nbsp;&nbsp;&nbsp;while (temp->next != nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = temp->next;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;temp->next = newNode;<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHASH%20TABLES
<strong>DSA: Hash Tables</strong><br>Why is `dataMap` declared as an array of pointers (`Node* dataMap[]`) rather than objects?	To allow slots to be `nullptr` (empty) initially and to facilitate dynamic Separate Chaining.	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHASH%20TABLES
<strong>DSA: Hash Tables</strong><br>Write a function to check if two vectors have a common item in O(n) time.	<pre style='text-align:left; font-family:monospace;'><code>bool itemInCommon(vector<int> v1, vector<int> v2) {<br>&nbsp;&nbsp;unordered_map<int, bool> map;<br>&nbsp;&nbsp;for (auto i : v1) map[i] = true;<br>&nbsp;&nbsp;for (auto j : v2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (map[j]) return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return false;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHASH%20TABLES
<strong>DSA: BST</strong><br>What is the Binary Search Tree invariant?	Left child < Parent < Right child.	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FBST
<strong>DSA: BST</strong><br>Write the iterative `insert(int value)` function.<br>Context: `Node* root`.	<pre style='text-align:left; font-family:monospace;'><code>bool insert(int value) {<br>&nbsp;&nbsp;Node* newNode = new Node(value);<br>&nbsp;&nbsp;if (root == nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;root = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;Node* temp = root;<br>&nbsp;&nbsp;while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (newNode->value == temp->value) return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;if (newNode->value < temp->value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (temp->left == nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp->left = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = temp->left;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (temp->right == nullptr) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp->right = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = temp->right;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FBST
<strong>DSA: BST</strong><br>Write the `contains(int value)` function.	<pre style='text-align:left; font-family:monospace;'><code>bool contains(int value) {<br>&nbsp;&nbsp;if (root == nullptr) return false;<br>&nbsp;&nbsp;Node* temp = root;<br>&nbsp;&nbsp;while (temp) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (value < temp->value) temp = temp->left;<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (value > temp->value) temp = temp->right;<br>&nbsp;&nbsp;&nbsp;&nbsp;else return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return false;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FBST
<strong>DSA: Doubly Linked List</strong><br>Write the `append(int value)` method.<br>Context: `Node* head`, `Node* tail`, `length`.	<pre style='text-align:left; font-family:monospace;'><code>void append(int value) {<br>&nbsp;&nbsp;Node* newNode = new Node(value);<br>&nbsp;&nbsp;if (length == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;head = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;tail = newNode;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;tail->next = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;newNode->prev = tail;<br>&nbsp;&nbsp;&nbsp;&nbsp;tail = newNode;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;length++;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDoubly%20linked%20list
<strong>DSA: Doubly Linked List</strong><br>Write the `deleteLast()` method.<br>Context: `Node* tail`.	<pre style='text-align:left; font-family:monospace;'><code>void deleteLast() {<br>&nbsp;&nbsp;if (length == 0) return;<br>&nbsp;&nbsp;Node* temp = tail;<br>&nbsp;&nbsp;if (length == 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;head = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;tail = nullptr;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;tail = tail->prev;<br>&nbsp;&nbsp;&nbsp;&nbsp;tail->next = nullptr;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;delete temp;<br>&nbsp;&nbsp;length--;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDoubly%20linked%20list
<strong>DSA: Doubly Linked List</strong><br>Write the `get(int index)` optimized logic.<br>Context: Divide and Conquer.	<pre style='text-align:left; font-family:monospace;'><code>Node* get(int index) {<br>&nbsp;&nbsp;if (index < 0 || index >= length) return nullptr;<br>&nbsp;&nbsp;Node* temp = head;<br>&nbsp;&nbsp;if (index < length / 2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < index; i++) temp = temp->next;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;temp = tail;<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = length - 1; i > index; i--) temp = temp->prev;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return temp;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDoubly%20linked%20list
<strong>DSA: Doubly Linked List</strong><br>Write the `reverse()` method.<br>Context: Swap next/prev.	<pre style='text-align:left; font-family:monospace;'><code>void reverse() {<br>&nbsp;&nbsp;Node* curr = head;<br>&nbsp;&nbsp;head = tail;<br>&nbsp;&nbsp;tail = curr;<br>&nbsp;&nbsp;Node* after = nullptr;<br>&nbsp;&nbsp;for (int i = 0; i < length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;after = curr->next;<br>&nbsp;&nbsp;&nbsp;&nbsp;curr->next = curr->prev;<br>&nbsp;&nbsp;&nbsp;&nbsp;curr->prev = after;<br>&nbsp;&nbsp;&nbsp;&nbsp;curr = after;<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDoubly%20linked%20list
<strong>DSA: Dynamic Programming</strong><br>What are the two essential properties for a problem to be considered a DP problem?	1. <strong>Overlapping Sub-problems</strong> (Repeated work).<br>2. <strong>Optimized Substructure</strong> (Optimal solution built from sub-solutions).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDynamic%20programming
<strong>DSA: Dynamic Programming</strong><br>Write the <strong>Memoized (Top-Down)</strong> Fibonacci function.<br>Context: `vector<int> memo`.	<pre style='text-align:left; font-family:monospace;'><code>int fib(int n) {<br>&nbsp;&nbsp;if (memo[n] != -1) return memo[n];<br>&nbsp;&nbsp;if (n == 0 || n == 1) return n;<br>&nbsp;&nbsp;memo[n] = fib(n - 1) + fib(n - 2);<br>&nbsp;&nbsp;return memo[n];<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FDynamic%20programming
<strong>DSA: Sorting</strong><br>Write the `InsertionSort` algorithm.	<pre style='text-align:left; font-family:monospace;'><code>void InsertionSort(int arr[], int size) {<br>&nbsp;&nbsp;for (int i = 1; i < size; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int j = i - 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;while (j > -1 && arr[j + 1] < arr[j]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(arr[j + 1], arr[j]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FSORT
<strong>DSA: Sorting</strong><br>Write the `SelectionSort` algorithm.	<pre style='text-align:left; font-family:monospace;'><code>void SelectionSort(int arr[], int size) {<br>&nbsp;&nbsp;for (int i = 0; i < size; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;int minIndex = i;<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = i + 1; j < size; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[j] < arr[minIndex]) minIndex = j;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;if (i != minIndex) swap(arr[i], arr[minIndex]);<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FSORT
<strong>DSA: Sorting</strong><br>Write the `BubbleSort` algorithm.	<pre style='text-align:left; font-family:monospace;'><code>void BubbleSort(int arr[], int size) {<br>&nbsp;&nbsp;for (int i = size - 1; i > 0; i--) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < i; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FSORT
<strong>DSA: Bucket Sort</strong><br>What is the time complexity of Bucket Sort and when should it be used?	Time: <strong>O(n)</strong>.<br>Use when elements are distributed over a <strong>small, finite range</strong> (e.g., 0, 1, 2).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fbucket%20sort
<strong>DSA: Quick Sort</strong><br>Write the `pivot` helper function.<br>Context: Partitions array, returns pivot index.	<pre style='text-align:left; font-family:monospace;'><code>int pivot(int array[], int pivotIndex, int endIndex) {<br>&nbsp;&nbsp;int swapIndex = pivotIndex;<br>&nbsp;&nbsp;for (int i = pivotIndex + 1; i <= endIndex; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (array[i] < array[pivotIndex]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swapIndex++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(array[swapIndex], array[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;swap(array[pivotIndex], array[swapIndex]);<br>&nbsp;&nbsp;return swapIndex;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fquick%20sort
<strong>DSA: Quick Sort</strong><br>Write the `quickSort` recursive function.	<pre style='text-align:left; font-family:monospace;'><code>void quickSort(int array[], int leftIndex, int rightIndex) {<br>&nbsp;&nbsp;if (leftIndex >= rightIndex) return;<br>&nbsp;&nbsp;int pivotIndex = pivot(array, leftIndex, rightIndex);<br>&nbsp;&nbsp;quickSort(array, leftIndex, pivotIndex - 1);<br>&nbsp;&nbsp;quickSort(array, pivotIndex + 1, rightIndex);<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fquick%20sort
<strong>DSA: Merge Sort</strong><br>Write the `merge` helper function.<br>Context: Merges two sorted subarrays.	<pre style='text-align:left; font-family:monospace;'><code>void merge(int array[], int leftIndex, int midIndex, int rightIndex) {<br>&nbsp;&nbsp;int leftSize = midIndex - leftIndex + 1;<br>&nbsp;&nbsp;int rightSize = rightIndex - midIndex;<br>&nbsp;&nbsp;int leftArr[leftSize], rightArr[rightSize];<br><br>&nbsp;&nbsp;for (int i = 0; i < leftSize; i++) leftArr[i] = array[leftIndex + i];<br>&nbsp;&nbsp;for (int j = 0; j < rightSize; j++) rightArr[j] = array[midIndex + 1 + j];<br><br>&nbsp;&nbsp;int i = 0, j = 0, k = leftIndex;<br>&nbsp;&nbsp;while (i < leftSize && j < rightSize) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (leftArr[i] <= rightArr[j]) array[k++] = leftArr[i++];<br>&nbsp;&nbsp;&nbsp;&nbsp;else array[k++] = rightArr[j++];<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;while (i < leftSize) array[k++] = leftArr[i++];<br>&nbsp;&nbsp;while (j < rightSize) array[k++] = rightArr[j++];<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fmerge%20sort
<strong>DSA: Merge Sort</strong><br>Write the `mergeSort` recursive function.	<pre style='text-align:left; font-family:monospace;'><code>void mergeSort(int array[], int leftIndex, int rightIndex) {<br>&nbsp;&nbsp;if (leftIndex >= rightIndex) return;<br>&nbsp;&nbsp;int midIndex = leftIndex + (rightIndex - leftIndex) / 2;<br>&nbsp;&nbsp;mergeSort(array, leftIndex, midIndex);<br>&nbsp;&nbsp;mergeSort(array, midIndex + 1, rightIndex);<br>&nbsp;&nbsp;merge(array, leftIndex, midIndex, rightIndex);<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fmerge%20sort
<strong>DSA: Heaps</strong><br>In a vector-based heap, what are the formulas for Left Child, Right Child, and Parent?	<strong>Left Child</strong>: `2 * index + 1`<br><strong>Right Child</strong>: `2 * index + 2`<br><strong>Parent</strong>: `(index - 1) / 2`	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHEAP
<strong>DSA: Heaps</strong><br>Write the `insert(int value)` function for a Heap.<br>Context: Bubble up.	<pre style='text-align:left; font-family:monospace;'><code>void insert(int value) {<br>&nbsp;&nbsp;heap.push_back(value);<br>&nbsp;&nbsp;int current = heap.size() - 1;<br>&nbsp;&nbsp;while (current > 0 && heap[current] > heap[parent(current)]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;swap(heap[current], heap[parent(current)]);<br>&nbsp;&nbsp;&nbsp;&nbsp;current = parent(current);<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FHEAP
<strong>DSA: Graphs</strong><br>Write the `addVertex` function for an Adjacency List.	<pre style='text-align:left; font-family:monospace;'><code>bool addVertex(string vertex) {<br>&nbsp;&nbsp;if (adjList.count(vertex) == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;adjList[vertex];<br>&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return false;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FGRAPH
<strong>DSA: Graphs</strong><br>Write the `addEdge` function.	<pre style='text-align:left; font-family:monospace;'><code>bool addEdge(string v1, string v2) {<br>&nbsp;&nbsp;if (adjList.count(v1) && adjList.count(v2)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;adjList.at(v1).insert(v2);<br>&nbsp;&nbsp;&nbsp;&nbsp;adjList.at(v2).insert(v1);<br>&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return false;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FGRAPH
<strong>DSA: Recursive BST</strong><br>Write the `rContains` recursive search function.	<pre style='text-align:left; font-family:monospace;'><code>bool rContains(Node* node, int value) {<br>&nbsp;&nbsp;if (node == nullptr) return false;<br>&nbsp;&nbsp;if (value == node->value) return true;<br>&nbsp;&nbsp;if (value < node->value) return rContains(node->left, value);<br>&nbsp;&nbsp;else return rContains(node->right, value);<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Frecursive%20BST
<strong>DSA: Tree Traversal</strong><br>Write the `BFS` function using a queue.	<pre style='text-align:left; font-family:monospace;'><code>void BFS() {<br>&nbsp;&nbsp;queue<Node*> myQueue;<br>&nbsp;&nbsp;myQueue.push(root);<br>&nbsp;&nbsp;while (!myQueue.empty()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Node* curr = myQueue.front();<br>&nbsp;&nbsp;&nbsp;&nbsp;myQueue.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;cout << curr->value << " ";<br>&nbsp;&nbsp;&nbsp;&nbsp;if (curr->left) myQueue.push(curr->left);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (curr->right) myQueue.push(curr->right);<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Ftree%20traversal
<strong>DSA: Tree Traversal</strong><br>Write the `DFSPreOrder` function.	<pre style='text-align:left; font-family:monospace;'><code>void DFSPreOrder(Node* curr) {<br>&nbsp;&nbsp;cout << curr->value << " ";<br>&nbsp;&nbsp;if (curr->left) DFSPreOrder(curr->left);<br>&nbsp;&nbsp;if (curr->right) DFSPreOrder(curr->right);<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Ftree%20traversal
<strong>DSA: Singly Linked List</strong><br>Write the `Node` class constructor.	<pre style='text-align:left; font-family:monospace;'><code>class Node {<br>public:<br>&nbsp;&nbsp;int value;<br>&nbsp;&nbsp;Node* next;<br>&nbsp;&nbsp;Node(int value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this->value = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;next = nullptr;<br>&nbsp;&nbsp;}<br>};</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FLinked%20List
<strong>DSA: Singly Linked List</strong><br>Write the `reverse` method for a Singly Linked List.	<pre style='text-align:left; font-family:monospace;'><code>void reverse() {<br>&nbsp;&nbsp;Node* temp = head;<br>&nbsp;&nbsp;head = tail;<br>&nbsp;&nbsp;tail = temp;<br>&nbsp;&nbsp;Node* after = nullptr;<br>&nbsp;&nbsp;Node* before = nullptr;<br>&nbsp;&nbsp;for (int i = 0; i < length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;after = temp->next;<br>&nbsp;&nbsp;&nbsp;&nbsp;temp->next = before;<br>&nbsp;&nbsp;&nbsp;&nbsp;before = temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;temp = after;<br>&nbsp;&nbsp;}<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FLinked%20List
<strong>DSA: Stack (LL)</strong><br>Write the `push(int value)` method for a Stack.<br>Context: `Node* top`.	<pre style='text-align:left; font-family:monospace;'><code>void push(int value) {<br>&nbsp;&nbsp;Node* newNode = new Node(value);<br>&nbsp;&nbsp;newNode->next = top;<br>&nbsp;&nbsp;top = newNode;<br>&nbsp;&nbsp;height++;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fstack
<strong>DSA: Queue (LL)</strong><br>Write the `enqueue(int value)` method for a Queue.<br>Context: `Node* first`, `Node* last`.	<pre style='text-align:left; font-family:monospace;'><code>void enqueue(int value) {<br>&nbsp;&nbsp;Node* newNode = new Node(value);<br>&nbsp;&nbsp;if (length == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;first = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;last = newNode;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;last->next = newNode;<br>&nbsp;&nbsp;&nbsp;&nbsp;last = newNode;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;length++;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fqueue
<strong>DSA: Queue (LL)</strong><br>Write the `dequeue()` method.	<pre style='text-align:left; font-family:monospace;'><code>int dequeue() {<br>&nbsp;&nbsp;if (length == 0) return INT_MIN;<br>&nbsp;&nbsp;Node* temp = first;<br>&nbsp;&nbsp;int val = first->value;<br>&nbsp;&nbsp;if (length == 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;first = nullptr;<br>&nbsp;&nbsp;&nbsp;&nbsp;last = nullptr;<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;first = first->next;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;delete temp;<br>&nbsp;&nbsp;length--;<br>&nbsp;&nbsp;return val;<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Fqueue
<strong>DSA: Algorithms</strong><br>Write code to reverse an array using an auxiliary array.	<pre style='text-align:left; font-family:monospace;'><code>int n = sizeof(arr)/sizeof(arr[0]);<br>int reversed[n];<br>for(int i = 0; i < n; i++) {<br>&nbsp;&nbsp;reversed[i] = arr[n - i - 1];<br>}</code></pre>	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2Freverse%20an%20array
<strong>DSA: Big O</strong><br>What are the two main simplification rules for Big O analysis?	1. Drop Constants (e.g., 2n -> n).<br>2. Drop Non-Dominants (e.g., n^2 + n -> n^2).	obsidian://open?vault=mohamed&file=programming%2FDSA%2Fscotte%20barette%20-%20C%2B%2B%20Data%20Structures%20%26%20Algorithms%2FBIG%20(O)